---
title:  "Tarea 1 - IN5162, Semestre Primavera 2025"
author: Lamich, Muñoz, Venegas.
date:   "`r format(Sys.time(), '%d %B, %Y')`"

output:
  html_document:
    df_print: paged
    theme: simplex
    highlight: tango
    toc: no
encoding: UTF-8
---

<!-- 
Author  	  : Marcel Goic
Description	: Comparación de precios de Abarrotes
						- v.0.0 (14/Abr/2022). First Version
						- v.0.0 (14/Aug/2025). Add basket forecasting
Notes       : 
-->

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Preliminares

(0.0 puntos) Escriban acá todos los comandos que necesita ejecutar antes de abordar las preguntas de la tarea (carga de librerías, lectura de datos, limpieza de la data, transformación de variables y todo lo que necesite).

#### Preparación Tarea

```{r P0 Corremos libreria}
#Exploración de datos
library(readxl)
library(ggplot2)
library(dplyr)
library(kableExtra)
library(modelsummary)
library(caret)
library(earth)
library(randomForest)
library(tidyr)
```

```{r P0 Limpiamos objetos}

rm(list=ls())         # Limpia la lista de objetos 
graphics.off()        # Limpia la lista de gráficos
options(digits = 5)   # Número de dígitos a utilizar

```

```{r P0 Fijamos directorio}
setwd("/Users/leandrovenegas/Documents/GitHub/Uni/Ingenieria de marketing/Tarea1")  # fijando el directorio de trabajo
```

```{r P0 Leemos la base}
#Exploración de datos
# Leemos el archivo CSV.
datos_precios = read_excel("Canasta_de_productos.xlsx")
Tipo_cambio <- read.csv("Tipo_cambio.csv")
head(datos_precios)
head(Tipo_cambio)
```

```{r}
#Pasar a formato largo (de columnas de países a columna Pais + TipoCambio)
Tipo_Cambio <- Tipo_cambio %>%
  pivot_longer(
    cols = c(Argentina, Chile, Colombia, España, Perú, Portugal, UK),
    names_to = "Pais",
    values_to = "TipoCambio"
  )

View(Tipo_Cambio)

```





```{r P0 Transformamos la base}

#Cambiamos Sub-categoria por Sub_categoria

# Renombramos únicamente la columna que nos falta
datos_precios <- datos_precios %>%
  rename(Sub_categoria = `Sub-categoria`)

# Creamos una variable que se llame precio final, para explorar si existen cambios en cuanto a las ofertas que ofrecen las cadenas de supermercados

datos_precios <- datos_precios %>%
  mutate(Precio_Final = ifelse(!is.na(Precio_Oferta) & Promocion == 1, Precio_Oferta, Precio_Normal))

#Y eliminamos precio oferta, ya que no lo necesitamos con la nueva variable
datos_precios <- datos_precios %>%
  select(-Precio_Oferta)

str(datos_precios)
summary(datos_precios)


#Numerica para año
datos_precios$Ano <- as.numeric(datos_precios$Ano)
summary(datos_precios$Ano)
summary(datos_precios$Mes)
#Veamos datos

# Primero defines los meses en orden
meses <- c("Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio",
           "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre")

# Luego conviertes la columna "Mes" en factor ordenado y después a número
datos_precios$Mes <- match(datos_precios$Mes, meses)
datos_precios$Mes <- as.numeric(datos_precios$Mes)

print(datos_precios$Mes)
```

```{r}
#Unir con la base de precios (df_precios)
datos_precios_tc <- datos_precios %>%
  left_join(Tipo_Cambio, by = c("Pais", "Ano", "Mes")) %>%
  mutate(
    Precio_Normal_usd = Precio_Normal * TipoCambio,
    Precio_Final_usd  = Precio_Final  * TipoCambio
  )

View(datos_precios_tc)

```


```{r}
# --- Filtrado y conteo de Peso_Volumen ---
# Contar productos menores a 0.1 y mayores/iguales
conteo_menores <- datos_precios_tc %>% filter(Peso_Volumen < 0.1) %>% nrow()
conteo_mayores <- datos_precios_tc %>% filter(Peso_Volumen >= 0.1) %>% nrow()

cat("Productos con Peso_Volumen < 0.1:", conteo_menores, "\n")
cat("Productos con Peso_Volumen >= 0.1:", conteo_mayores, "\n")

# Eliminar los que son menores a 0.1, porque son solo el 8% de los datos
datos_precios_tc <- datos_precios_tc %>% filter(Peso_Volumen >= 0.1)

# Revisar estructura final
summary(datos_precios_tc$Peso_Volumen)
View(datos_precios_tc)
```


```{r}

#ademas agregamos precio unitario, para considerar el precio por volumen.
datos_precios_tc <- datos_precios_tc %>%
  mutate(PrecioU_oferta_usd = Precio_Final_usd/Peso_Volumen, PrecioU_Normal_usd = Precio_Normal_usd/Peso_Volumen)


View(datos_precios_tc)
```

```{r}

datos_precios_tc <- datos_precios_tc %>%
  select(-Date,-Precio_Final,-Precio_Normal,-TipoCambio,-Precio_Final_usd,-Precio_Normal_usd,-Peso_Volumen)

View(datos_precios_tc)

```


Ademas no todas las columnas son importantes, no podemos comparar el precio de la sal, azucar y endulzante por ejemplo. Para esto debemos agrupar los productos por el tipo de producto, es decir todas las azucar que se venden en chile se deben agrupar en alguna unica.

Por lo que, hacemos un group by y calculamos el promedio:

```{r agrupamos por sub_categoria, Pais y Cadena}
#precio_por_cadena <- datos_precios_tc %>% group_by(Pais,Ano,Mes, Cadena, Sub_categoria) %>%
#  summarise(Precio_Unitario_Promedio = mean(PrecioU_oferta_usd, na.rm = TRUE)) #%>%
  #ungroup() # Es una buena práctica desagrupar al final
#View(precio_por_cadena)
```

```{r agrupamos por sub_categoria Y Pais}
precio_por_pais <- datos_precios_tc %>%
  group_by(Pais, Sub_categoria) %>%
  summarise(Precio_Unitario_Promedio = mean(PrecioU_oferta_usd, na.rm = TRUE))# %>%
  #ungroup() # Es una buena práctica desagrupar al final
View(precio_por_pais)
```





## Desarrollo

Documenten acá el desarrollo de su tarea por pregunta.

#### Pregunta 1

(1.0 puntos) Exploren los datos para entender la distribución del precio de los abarrotes y ver qué variables podrían ayudar a explicar posibles diferencias en el nivel de precios entre países.
```{r Exploración de datos}


# 3. Generamos el mapa de calor (heatmap)
ggplot(precio_por_pais, aes(x = Sub_categoria, y = Pais, fill = Precio_Unitario_Promedio)) +
  geom_tile(color = "white") + # geom_tile() es la función para crear el heatmap
  scale_fill_viridis_c(option = "plasma") + # Una paleta de colores más atractiva
  labs(
    title = "Mapa de Calor de Precios Unitarios Promedio",
    subtitle = "Comparación de todas las Subcategorías entre todos los Países",
    x = "Subcategoría de Producto",
    y = "País",
    fill = "Precio Promedio (USD)"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1) # Gira las etiquetas para que no se solapen
  )


```


Notamos que, el mapa de calor nos hace pensar que por categoria, los datos tienen un precio parecido dentro de un mismo pais.



```{r P1}
#Exploración de datos

# Generamos el gráfico de dispersión
ggplot(precio_por_pais, aes(x = Sub_categoria, y = Precio_Unitario_Promedio, color = Pais)) +
  geom_jitter(width = 0.25, alpha = 0.7, size = 2.5) + # Jitter para evitar solapamiento
  labs(
    title = "Dispersión de Precios Promedio por Subcategoría y País",
    subtitle = "Cada punto es el precio promedio de una categoría en un país",
    x = "Subcategoría de Producto",
    y = "Precio Unitario Promedio (USD)",
    color = "País"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1) # Rotar etiquetas del eje X
  )
```


```{r}

#Subimos el nivel de agregación, para usar solo categoria.
precio_por_categoria <- datos_precios_tc %>%
  group_by(Pais, Categoria) %>%
  summarise(Precio_Unitario_Promedio = mean(PrecioU_oferta_usd, na.rm = TRUE))# %>%
  #ungroup() # Es una buena práctica desagrupar al final
View(precio_por_categoria)

```





```{r}

# Filtramos directamente, manteniendo solo las categorías que aparecen en todos los paises.
# Esta es la forma más directa de hacerlo.
precio_categorias_comunes <- precio_por_categoria %>%
  group_by(Categoria) %>%
  filter(n_distinct(Pais) == 7) %>%
  ungroup()

# Verificamos el resultado para confirmar que solo tenemos
View(precio_categorias_comunes)
```


Exploramos solo por un conjunto de productos.

```{r}

#Mini filtro por algunos paises.
precio_categorias_comunes1 <- precio_categorias_comunes %>%
  filter(Pais %in% c("Perú", "Colombia", "UK"))

#Graficamos.
ggplot(precio_categorias_comunes1, aes(x = Categoria, y = Precio_Unitario_Promedio, color = Pais)) +
  geom_jitter(width = 0.25, alpha = 0.7, size = 2.5) + # Jitter para evitar solapamiento
  labs(
    title = "Dispersión de Precios Promedio por Subcategoría y País",
    subtitle = "Cada punto es el precio promedio de una categoría en un país",
    x = "Categoría de Producto",
    y = "Precio Unitario Promedio (USD)",
    color = "País"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1) # Rotar etiquetas del eje X
  )

```


```{r}
#Subimos el nivel de agregación, para usar solo 1 conjunto de productos y obtenemos promedio.
precio_por_pais <- datos_precios_tc %>%
  group_by(Pais) %>%
  summarise(Precio_Unitario_Promedio = mean(PrecioU_oferta_usd, na.rm = TRUE))# %>%
  #ungroup() # Es una buena práctica desagrupar al final
View(precio_por_pais)


#Graficamos promediando todos los productos de un pais.
ggplot(precio_por_pais, aes(x = Pais, y = Precio_Unitario_Promedio)) +
  geom_jitter(width = 0.25, alpha = 0.7, size = 2.5) + # Jitter para evitar solapamiento
  labs(
    title = "Dispersión de Precios Promedio por Subcategoría y País",
    subtitle = "Cada punto es el precio promedio de una categoría en un país",
    x = "Categoría de Producto",
    y = "Precio Unitario Promedio (USD)",
    color = "País"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1) # Rotar etiquetas del eje X
  )
```


#### Pregunta 2

Usando los aprendizajes derivados de la exploración de datos, utilicen un enfoque de regresión lineal para examinar cuantitativamente qué factores determinan los distintos niveles de precios que pueden haber. En particular, consideren que nos interesa comparar niveles de precios entre países. 
     
a. (1.0 puntos) Propongan al menos dos especificaciones alternativas para el objetivo propuesto. Justifiquen muy brevemente por qué las variables explicativas que está incluyendo en el modelo tienen sentido desde el punto de vista del problema. Justifiquen además el nivel de agregación escogido y los índices considerados en el modelo.

```{r P2_a}
#lm models

```

b. (1.0 puntos) Sobre los dos modelos planteados en la parte anterior, apliquen algún método de selección automática de variables aprendido en clases y compare con respecto a los resultados anteriores. Deben indicar cuáles variables descartan.

```{r P2_b}
#automatic variable selection
```

#### Pregunta 3

(1.0 puntos) Usen al menos dos de los modelos de aprendizaje de máquinas que vimos en clases (MARS, kNN, regression tree o random forest) para generar un pronóstico de precios para un país, año, mes y produto dado. Comparen la capacidad de estos modelos con respecto a los de regresión lineal utilizando métricas de desempeño (MSE, RMSE o MAE). Discutan brevemente sus resultados y el modelo que recomendaría usar.

```{r P3}
#Machine learning models
```

#### Pregunta 4
En vez de pedir que generen una canasta para cada mes año y pais, sugeriría que eligan 3 canasta con al menos 5 productos de su elección y pronostiquen el precio para todos los paises en una fecha en particular. Asi tenemos más variación en las respuestas y dificultamos la copia.

a. (1.0 puntos) Elaboren tres canastas de abarrotes con al menos cinco productos de sus preferencias para todos los países en alguna fecha cualquiera. Pronostiquen su precio corregido por moneda (USD) incluyendo variables explicativas relevantes. Comparen el precio de Chile con respecto al resto de países. 

```{r P4a}
# pronóstico de canasta de abarrotes corregido por moneda
```

b. (0.5 puntos) Utilicen las mismas canastas de abarrotes y pronostiquen su precio corregido por moneda (USD) y por paridad de poder adquisitivo (ppa) incluyendo variables explicativas relevantes. Comparen el precio de Chile con respecto al resto de países. Expliquen brevemente en qué se diferencia esta métrica en comparación a solo corregir por moneda.

```{r P4b}
# pronóstico de canasta de abarrotes corregido por moneda y por ppa

```

## Resumen

(0.5 puntos) Resuman ejecutivamente sus resultados y provean un resumen conciso de los aprendizajes y sugerencias relevantes.

```{r Resumen}
#Summary
```

## Anexos

Documenta acá cualquier otro adicional que consideres útil tener de referencia. 


## Roles

Todos los participantes del grupo de trabajo declaran que su participación queda bien reflejada en la siguiente tabla.  

```{r, message=FALSE, echo=FALSE, warning=FALSE}
library(dplyr)
library(kableExtra)

roles <- data.frame(
  integrantes = c("Integrante 1", "Integrante 2", "Integrante 3"),
  P1 = c("código", "interpretación", "código e interpretación"),
  P2 = c("interpretación", "-", "código e interpretación"),
  P3 = c("-", "-", "código e interpretación"),
  P4 = c("interpretación", "interpretación", "código"),
  Resumen = c("interpretación", "código", "-")
)

roles %>%
  kbl(caption = "**Tabla N+1:** Roles de los Participantes en el trabajo") %>%
  kable_classic(full_width = FALSE, html_font = "Cambria")
```


Asimismo, los participantes del grupo de trabajo declaran que el uso de herramientas de inteligencia artificial (IA) queda bien reflejada en la siguiente tabla.
```{r, echo=FALSE}
iarole <- data.frame(
  preguntas = c("P1", "P2", "P3", "P4", "Resumen"), 
  uso = c("escribir códigos para formatear los datos", 
          "interpretar los resultados", 
          "-", 
          "-", 
          "Encontrar errores en el código"), 
  herramienta = c("Chat GPT-5", 
                  "Ninguna", 
                  "Chat GPT-5", 
                  "Chat GPT-5", 
                  "Chat GPT-5, DeepSeek")
)

iarole %>%
  kbl(caption = "**Tabla N+2:** Rol de la IA en el trabajo") %>%
  kable_classic(full_width = F, html_font = "Cambria")

```
