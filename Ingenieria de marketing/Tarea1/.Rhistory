head(macro)
# Renombramos la columna con _ para que sea intuitivo al momento de trabajar las bases.
datos_precios <- datos_precios %>% rename(Sub_categoria = `Sub-categoria`)
# Transformamos los años a numerico.
datos_precios$Ano <- as.numeric(datos_precios$Ano)
# Creamos una variable que se llame precio final, para explorar si existen cambios en cuanto a las ofertas que ofrecen las cadenas de supermercados.Es la variable que utilizaremos para el caso de estudio.
datos_precios <- datos_precios %>%
mutate(Precio_Final = ifelse(!is.na(Precio_Oferta) & Promocion == 1, Precio_Oferta, Precio_Normal))
#Y eliminamos precio oferta, ya que no lo necesitamos con la nueva variable
datos_precios <- datos_precios %>% select(-Precio_Oferta)
# Primero se definen los meses en orden.
meses <- c("Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio",
"Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre")
# Luego se convierte la columna "Mes" en factor ordenado y después a número.
datos_precios$Mes <- match(datos_precios$Mes, meses)
datos_precios$Mes <- as.numeric(datos_precios$Mes)
head(datos_precios$Mes) #Corroboramos.
#Pasar a formato largo (de columnas de países a columna Pais + TipoCambio)
Tipo_Cambio <- Tipo_cambio %>%
pivot_longer(
cols = c(Argentina, Chile, Colombia, España, Perú, Portugal, UK),
names_to = "Pais",
values_to = "TipoCambio"
)
#Unir con la base de precios (df_precios)
datos_precios_tc <- datos_precios %>%
left_join(Tipo_Cambio, by = c("Pais", "Ano", "Mes")) %>%
mutate(
Precio_Normal_usd = Precio_Normal * TipoCambio, # Calculamos todo en dolares.
Precio_Final_usd  = Precio_Final  * TipoCambio
)
# Ademas agregamos precio unitario, para considerar el mismo peso para todos los productos.
datos_precios_tc <- datos_precios_tc %>%
mutate(PrecioU_oferta_usd = Precio_Final_usd/Peso_Volumen, PrecioU_Normal_usd = Precio_Normal_usd/Peso_Volumen)
#Limpiamos las columnas que no utilizaremos para limpiar el trabajo realizado.
datos_precios_tc <- datos_precios_tc %>%
select(-Date,-Precio_Final,-Precio_Normal,-TipoCambio,-Precio_Final_usd,-Precio_Normal_usd,-Peso_Volumen)
head(datos_precios_tc) # Resultado final
precio_por_subcategoria <- datos_precios_tc %>%
group_by(Ano, Mes, Pais, Sub_categoria) %>% #Agrupamos
summarise(Precio_Unitario_Promedio = mean(PrecioU_oferta_usd, na.rm = TRUE))#Calculamos promedio del grupo.
#Subimos el nivel de agregación, para usar solo categoria.
precio_por_categoria <- datos_precios_tc %>%
group_by(Pais, Categoria) %>%
summarise(Precio_Unitario_Promedio = mean(PrecioU_oferta_usd, na.rm = TRUE))
#Subimos el nivel de agregación, para usar solo 1 conjunto de productos y obtenemos promedio.
precio_por_pais <- datos_precios_tc %>%
group_by(Pais) %>%
summarise(Precio_Unitario_Promedio = mean(PrecioU_oferta_usd, na.rm = TRUE))
# Eliminar subcategorías específicas con un filtro de subcategoria.
precio_por_subcategoria <- precio_por_subcategoria %>%
filter(!Sub_categoria %in% c("Ajo", "Albahaca", "Oregano",
"Endulzante", "Canela",
"Laurel", "Chocolate", "Té","Te","Café","Dulces","Aceto"))
# Eliminar categorías específicas
precio_por_categoria <- precio_por_categoria %>%
filter(!Categoria %in% c("Especias, condimentos y caldos",
"Azúcar, sal y sucedáneos",
"Cafe y te",
"Café y té",
"Dulces y postres no congelados sin cereales",
"Sopas"))
# Filtramos directamente, manteniendo solo las categorías y subcategorias que aparecen en todos los paises.
precio_por_subcategoria <- precio_por_subcategoria %>%
group_by(Sub_categoria) %>%
filter(n_distinct(Pais) == 7) %>% # Este filtro funciona como agrupar las subcategoria y que solo existan 7 en total, por los 7 paises considerados. Así si solo existen 6, no se considera la subcategoria para el caso de estudio.
ungroup()
precio_por_categoria <- precio_por_categoria %>%
group_by(Categoria) %>%
filter(n_distinct(Pais) == 7) %>%
ungroup()
# Unir bases por País y Año, con variables macro Y micro para pregunta 2.
precio_por_subcategoria1 <- datos_precios_tc %>%
select(Ano, Mes, Pais, Sub_categoria, PrecioU_oferta_usd) %>%
group_by(Ano, Mes, Pais, Sub_categoria) %>%
mutate(Precio_Unitario_Promedio = mean(PrecioU_oferta_usd, na.rm = TRUE)) %>%
ungroup() # Tratamos los datos de la forma en que lo hicimos antes para categorias.
macro <- macro %>%
mutate(Pais = if_else(Pais == "PERU", "Perú", Pais))
# Unimos con macro
data_macro <- precio_por_subcategoria1 %>%
inner_join(macro, by = c("Pais", "Ano")) %>%
mutate(GDPpc_miles = GDPpc / 1000)
View(macro)
# Si cargaste plyr u otro que choque con dplyr, lo bajas:
#if ("package:plyr" %in% search()) detach("package:plyr", unload = TRUE)
# fuerza a que select sea de dplyr
#select <- dplyr::select
# --- 1. Preparación de datos ---
set.seed(5162)
data_ag <- data_macro %>%
select(Ano, Mes, Pais, Sub_categoria,PrecioU_oferta_usd,GDPpc_miles,Arancel,UrbGrow,Import_PIB) %>%
mutate(across(c(Pais, Sub_categoria), as.factor)) %>%
filter(is.finite(PrecioU_oferta_usd))
#,Arancel,UrbGrow,Import_PIB,GDPpc_miles
# --- 2. División de datos ---
idx <- createDataPartition(data_ag$Sub_categoria, p = 0.8, list = FALSE)
train_df <- data_ag[idx, ]
test_df  <- data_ag[-idx, ]
fml <- PrecioU_oferta_usd ~ .
# --- 3. Entrenamiento de modelos ---
ctrl <- trainControl(method = "cv", number = 10, savePredictions = "final")
modelo_lm   <- train(fml, data = train_df, method = "lm", trControl = ctrl)
modelo_mars <- train(fml, data = train_df, method = "earth", trControl = ctrl, tuneGrid = expand.grid(degree=1, nprune=5:12))
modelo_rf   <- train(fml, data = train_df, method = "rf", trControl = ctrl, tuneGrid = expand.grid(mtry = 2:4), ntree = 100)
# --- 4. Comparación de métricas de desempeño ---
model_list <- list(LM = modelo_lm, MARS = modelo_mars, RF = modelo_rf)
results <- resamples(model_list)
summary(results)
# --- 5. Creación de Boxplots de Errores ---
# a) Realizamos las predicciones en el set de prueba
pred.lm   <- predict(modelo_lm,   newdata = test_df)
pred.mars <- predict(modelo_mars, newdata = test_df)
pred.rf   <- predict(modelo_rf,   newdata = test_df)
# b) Calculamos los errores de predicción (valor real - predicción)
error.df <- data.frame(
LM   = test_df$PrecioU_oferta_usd - pred.lm,
MARS = test_df$PrecioU_oferta_usd - pred.mars,
RF   = test_df$PrecioU_oferta_usd - pred.rf
)
# c) Generamos los boxplots
# Primero, configuramos la ventana gráfica para mostrar dos gráficos juntos
par(mfrow = c(1, 2))
# Gráfico 1: Errores de predicción (para ver el sesgo)
boxplot(error.df, main = "Errores de Predicción")
# Gráfico 2: Errores absolutos (para ver la magnitud del error)
boxplot(abs(error.df), main = "Errores Absolutos de Predicción")
# Reseteamos la configuración de la ventana gráfica
par(mfrow = c(1, 1))
# --- 6. Predicción puntual y comparación con valor real ---
new_caso <- expand.grid(
Pais = factor("Chile", levels = levels(train_df$Pais)),
Sub_categoria = factor("Panes", levels = levels(train_df$Sub_categoria)),
Ano  = 2022,
Mes  = 2,
Arancel = 1.0,
UrbGrow = 0.6,
Import_PIB = 39.6,
GDPpc_miles = 15.405
)
predicciones <- sapply(model_list, function(modelo) predict(modelo, newdata = new_caso))
obs <- data_ag %>%
filter(Ano==2022, Mes==2, Pais=="Chile", Sub_categoria=="Panes") %>%
slice(1) %>%
pull(PrecioU_oferta_usd)
pred_puntual <- data.frame(
Modelo = names(predicciones),
Prediccion = predicciones,
Observado = obs
)
print(pred_puntual)
#Summary
P0
En esta pregunta se prepararon los datos, para esto primero se cargó una base con el tipo de cambio en dólares para pasar todo a una misma moneda. Además se agregó una base con 7 variables macro que posteriormente se usarán como variables explicativas. Posteriormente se transforma la base para usar solo sub categoría ya que es representativo de los productos y es lo que realmente interesa. Además de definir un precio que es igual al de oferta cuando hay oferta y si no es el precio normal. Luego de esto se normalizaron los precios por el volumen y se eliminaron productos que quedaron con precios erróneos: especias entre otros. Finalmente se aseguró el hecho de que estén las mismas subcategorías en todos los países.
set.seed(5162) #Semilla
# Preparar la base de datos para corregir por ppa y dolar.
base_int <- data_macro %>%
left_join(Tipo_Cambio, by = c("Pais", "Ano", "Mes")) %>%
left_join(ppa, by = c("Pais", "Ano")) %>%
mutate(Precio_Int = PrecioU_oferta_usd / (TipoCambio * Factor_PPA)) %>%
filter(is.finite(Precio_Int)) %>%
select(Ano, Mes, Pais,Sub_categoria,GDPpc_miles,Arancel,UrbGrow,Import_PIB, Precio_Int) %>%
mutate(across(c(Pais, Sub_categoria), as.factor))
knitr::opts_chunk$set(echo = TRUE)
#Exploración de datos
library(readxl)
library(fixest)
library(ggplot2)
library(dplyr)
library(knitr)
library(glmnet)
library(kableExtra)
library(modelsummary)
library(caret)
library(earth)
library(randomForest)
library(tidyr)
rm(list=ls())         # Limpia la lista de objetos
graphics.off()        # Limpia la lista de gráficos
options(digits = 5)   # Número de dígitos a utilizar
#setwd("C:\Users\Leandro\Documents\github\Uni\Ingenieria de marketing")  # fijando el directorio de trabajo
#Exploración de datos
# Leemos el archivo xlsx de Canasta de productos.
datos_precios = read_excel("Canasta_de_productos.xlsx")
# Cargamos la base tipo de cambio.
Tipo_cambio <- read.csv("Tipo_cambio.csv")
# Cargamos la base de variables macros utilizadas.
macro <- read.csv("variables_macro.csv")
#Mostramos las bases.
head(datos_precios)
head(Tipo_cambio)
head(macro)
# Renombramos la columna con _ para que sea intuitivo al momento de trabajar las bases.
datos_precios <- datos_precios %>% rename(Sub_categoria = `Sub-categoria`)
# Transformamos los años a numerico.
datos_precios$Ano <- as.numeric(datos_precios$Ano)
# Creamos una variable que se llame precio final, para explorar si existen cambios en cuanto a las ofertas que ofrecen las cadenas de supermercados.Es la variable que utilizaremos para el caso de estudio.
datos_precios <- datos_precios %>%
mutate(Precio_Final = ifelse(!is.na(Precio_Oferta) & Promocion == 1, Precio_Oferta, Precio_Normal))
#Y eliminamos precio oferta, ya que no lo necesitamos con la nueva variable
datos_precios <- datos_precios %>% select(-Precio_Oferta)
# Primero se definen los meses en orden.
meses <- c("Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio",
"Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre")
# Luego se convierte la columna "Mes" en factor ordenado y después a número.
datos_precios$Mes <- match(datos_precios$Mes, meses)
datos_precios$Mes <- as.numeric(datos_precios$Mes)
head(datos_precios$Mes) #Corroboramos.
#Pasar a formato largo (de columnas de países a columna Pais + TipoCambio)
Tipo_Cambio <- Tipo_cambio %>%
pivot_longer(
cols = c(Argentina, Chile, Colombia, España, Perú, Portugal, UK),
names_to = "Pais",
values_to = "TipoCambio"
)
#Unir con la base de precios (df_precios)
datos_precios_tc <- datos_precios %>%
left_join(Tipo_Cambio, by = c("Pais", "Ano", "Mes")) %>%
mutate(
Precio_Normal_usd = Precio_Normal * TipoCambio, # Calculamos todo en dolares.
Precio_Final_usd  = Precio_Final  * TipoCambio
)
# Ademas agregamos precio unitario, para considerar el mismo peso para todos los productos.
datos_precios_tc <- datos_precios_tc %>%
mutate(PrecioU_oferta_usd = Precio_Final_usd/Peso_Volumen, PrecioU_Normal_usd = Precio_Normal_usd/Peso_Volumen)
#Limpiamos las columnas que no utilizaremos para limpiar el trabajo realizado.
datos_precios_tc <- datos_precios_tc %>%
select(-Date,-Precio_Final,-Precio_Normal,-TipoCambio,-Precio_Final_usd,-Precio_Normal_usd,-Peso_Volumen)
head(datos_precios_tc) # Resultado final
precio_por_subcategoria <- datos_precios_tc %>%
group_by(Ano, Mes, Pais, Sub_categoria) %>% #Agrupamos
summarise(Precio_Unitario_Promedio = mean(PrecioU_oferta_usd, na.rm = TRUE))#Calculamos promedio del grupo.
#Subimos el nivel de agregación, para usar solo categoria.
precio_por_categoria <- datos_precios_tc %>%
group_by(Pais, Categoria) %>%
summarise(Precio_Unitario_Promedio = mean(PrecioU_oferta_usd, na.rm = TRUE))
#Subimos el nivel de agregación, para usar solo 1 conjunto de productos y obtenemos promedio.
precio_por_pais <- datos_precios_tc %>%
group_by(Pais) %>%
summarise(Precio_Unitario_Promedio = mean(PrecioU_oferta_usd, na.rm = TRUE))
# Eliminar subcategorías específicas con un filtro de subcategoria.
precio_por_subcategoria <- precio_por_subcategoria %>%
filter(!Sub_categoria %in% c("Ajo", "Albahaca", "Oregano",
"Endulzante", "Canela",
"Laurel", "Chocolate", "Té","Te","Café","Dulces","Aceto"))
# Eliminar categorías específicas
precio_por_categoria <- precio_por_categoria %>%
filter(!Categoria %in% c("Especias, condimentos y caldos",
"Azúcar, sal y sucedáneos",
"Cafe y te",
"Café y té",
"Dulces y postres no congelados sin cereales",
"Sopas"))
# Filtramos directamente, manteniendo solo las categorías y subcategorias que aparecen en todos los paises.
precio_por_subcategoria <- precio_por_subcategoria %>%
group_by(Sub_categoria) %>%
filter(n_distinct(Pais) == 7) %>% # Este filtro funciona como agrupar las subcategoria y que solo existan 7 en total, por los 7 paises considerados. Así si solo existen 6, no se considera la subcategoria para el caso de estudio.
ungroup()
precio_por_categoria <- precio_por_categoria %>%
group_by(Categoria) %>%
filter(n_distinct(Pais) == 7) %>%
ungroup()
# Unir bases por País y Año, con variables macro Y micro para pregunta 2.
precio_por_subcategoria1 <- datos_precios_tc %>%
select(Ano, Mes, Pais, Sub_categoria, PrecioU_oferta_usd) %>%
group_by(Ano, Mes, Pais, Sub_categoria) %>%
mutate(Precio_Unitario_Promedio = mean(PrecioU_oferta_usd, na.rm = TRUE)) %>%
ungroup() # Tratamos los datos de la forma en que lo hicimos antes para categorias.
macro <- macro %>%
mutate(Pais = if_else(Pais == "PERU", "Perú", Pais)) #normalizamos el nombre de Perú
# Unimos con macro
data_macro <- precio_por_subcategoria1 %>%
inner_join(macro, by = c("Pais", "Ano")) %>%
mutate(GDPpc_miles = GDPpc / 1000)# Trasnformamos GDP por que su magnitud es grande.
# Ca,biamos el formato de marca propia y promoción
data_micro1 <- datos_precios_tc %>%
mutate(MarcaPropia = as.factor(Marca_propia),
Promocion = as.factor(Promocion))
#Unimos las bases con los vectores que nos importan.
data_unida_filtrada <- data_micro1 %>%
inner_join(precio_por_subcategoria, by = c("Ano", "Mes", "Pais", "Sub_categoria"))
#Seleccionamos solo las variables que nos importa dentro de la data unida.
data_micro <- data_unida_filtrada %>%
dplyr::select(Precio_Unitario_Promedio,PrecioU_oferta_usd, MarcaPropia, Promocion, Cadena, Categoria , Sub_categoria, Pais, Ano, Mes) %>%
na.omit()
# Creamos el dataframe a mano con los datos de PPA que obtuvimos.
ppa_ancho <- data.frame(
Pais = c("Argentina", "Chile", "Colombia", "España", "UK", "Perú", "Portugal"),
`2021` = c(38.783, 423.014, 1340.326, 0.588, 0.669, 1.734, 0.540),
`2022` = c(61.499, 436.528, 1373.871, 0.570, 0.638, 1.691, 0.525),
check.names = FALSE # Para se utilicen "2021" y "2022"
)
# Convertir el dataframe de PPA a formato largo, esto porque queremos filas.
ppa <- ppa_ancho %>%
pivot_longer(
cols = c(`2021`, `2022`),       # Las columnas que queremos transformar
names_to = "Ano",              # La nueva columna para los años
values_to = "Factor_PPA"       # La nueva columna para los valores de PPA
) %>%
mutate(Ano = as.integer(Ano)) # Convertimos la columna 'Ano' a número
#Exploración de datos
# Generamos el gráfico de dispersión
ggplot(precio_por_subcategoria, aes(x = Sub_categoria, y = Precio_Unitario_Promedio, color = Pais)) +
geom_jitter(width = 0.25, alpha = 0.7, size = 2.5) + # Jitter para evitar solapamiento
labs(
title = "Dispersión de Precios Promedio por Subcategoría y País",
subtitle = "Cada punto es el precio promedio de una categoría en un país",
x = "Subcategoría de Producto",
y = "Precio Unitario Promedio (USD)",
color = "País"
) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1) #Rotar etiquetas del eje X
)
#Mini filtro por algunos paises.
precio_categorias_comunes <- precio_por_categoria %>%
filter(Pais %in% c("Perú", "Colombia", "UK"))
#Graficamos.
ggplot(precio_categorias_comunes, aes(x = Categoria, y = Precio_Unitario_Promedio, color = Pais)) +
geom_jitter(width = 0.25, alpha = 0.7, size = 2.5) + # Jitter para evitar solapamiento
labs(
title = "Dispersión de Precios Promedio por Subcategoría y País",
subtitle = "Cada punto es el precio promedio de una categoría en un país",
x = "Categoría de Producto",
y = "Precio Unitario Promedio (USD)",
color = "País"
) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1) # Rotar etiquetas del eje X
)
#Graficamos promediando todos los productos de un pais.
ggplot(precio_por_pais, aes(x = Pais, y = Precio_Unitario_Promedio)) +
geom_jitter(width = 0.25, alpha = 0.7, size = 2.5) + # Jitter para evitar solapamiento
labs(
title = "Dispersión de Precios Promedio por Subcategoría y País",
subtitle = "Cada punto es el precio promedio de una categoría en un país",
x = "Categoría de Producto",
y = "Precio Unitario Promedio (USD)",
color = "País"
) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1) # Rotar etiquetas del eje X
)
# Ranking por producto y año
ranking_productos <- precio_por_subcategoria %>%
group_by(Ano, Sub_categoria) %>%
mutate(Rank_del_Pais = rank(Precio_Unitario_Promedio, ties.method = "first")) %>%
ungroup()
# Ranking agregado por país
ranking_final <- ranking_productos %>%
group_by(Pais) %>%
summarise(RankTotal = sum(Rank_del_Pais, na.rm = TRUE)) %>%
arrange(RankTotal)
# 4. Resultado
print(ranking_final)
#Ya tenemos cargada la base de macros, y transformada en P0.
# Estimamos con efectos fijos
modelo_macro_fe <- feols(
PrecioU_oferta_usd ~ GDPpc_miles + Arancel + UrbGrow +
LPI + Inflacion + Import_PIB + FoodImp | Sub_categoria + Ano,
data = data_macro
)
summary(modelo_macro_fe) #Tabla
#Datos micro cargados y transformados en P0.
modelo_micro_fe <- feols(
PrecioU_oferta_usd ~ MarcaPropia + Promocion + Cadena |
Categoria + Pais + Ano,
data = data_micro)
summary(modelo_micro_fe) #Tabla
modelo_micro_fesub <- feols(
PrecioU_oferta_usd ~ MarcaPropia + Promocion + Cadena |
Sub_categoria + Pais + Ano,
data = data_micro)
summary(modelo_micro_fesub) #Tabla
#Utilizamos la base macro ya procesada en p0.
data_macro_lasso <- data_macro %>%
dplyr::select(PrecioU_oferta_usd, GDPpc_miles, Arancel, UrbGrow, LPI, Inflacion, Import_PIB, FoodImp) %>%
na.omit()
#Variable dependiente
y_macro <- as.matrix(data_macro_lasso$PrecioU_oferta_usd)
#Matriz de regresores (incluye efectos fijos como dummies)
X_macro <- model.matrix(PrecioU_oferta_usd ~ GDPpc_miles + Arancel + UrbGrow + LPI + Inflacion + Import_PIB + FoodImp , data = data_macro_lasso )[, -1] # quitamos el intercepto
#Estimamos con LASSO y validación cruzada
set.seed(123) # semilla
cv_macro_lasso <- cv.glmnet(X_macro, y_macro, alpha = 1, standardize = TRUE)
#Lambda óptimo elegido por CV
cat("Lambda óptimo:", cv_macro_lasso$lambda.min, "\n")
#Variables seleccionadas con coeficiente 0
coef_macro <- coef(cv_macro_lasso, s = "lambda.min") #Extraemos el coeficiente
selected_vars <- rownames(coef_macro)[which(coef_macro != 0)]
cat("Variables seleccionadas por LASSO:\n")
print(selected_vars)
#Utilizamos la base micro ya procesada en p0.
#Variable dependiente
y_micro <- as.matrix(data_micro$PrecioU_oferta_usd)
#Matriz de regresores (incluye efectos fijos como dummies)
X_micro <- model.matrix(
PrecioU_oferta_usd ~ MarcaPropia + Promocion + Cadena +
factor(Sub_categoria) + factor(Pais) + factor(Ano),
data = data_micro
)[, -1] # quitamos el intercepto
#Estimación con LASSO y validación cruzada
set.seed(123)  # semilla
cv_micro_lasso <- cv.glmnet(X_micro, y_micro, alpha = 1, standardize = TRUE)
#Lambda óptimo elegido por CV
cat("Lambda óptimo:", cv_micro_lasso$lambda.min, "\n")
##Variables seleccionadas con coeficiente 0
coef_micro <- coef(cv_micro_lasso, s = "lambda.min")
selected_vars_micro <- rownames(coef_micro)[which(coef_micro != 0)]
#limpiamos interceptos de subcategoria, Pais y Ano
selected_vars_micro_clean <- selected_vars_micro[!grepl("Intercept|Sub_categoria|Pais|Ano", selected_vars_micro)]
cat("Variables seleccionadas por LASSO (solo micro, sin FE):\n")
print(selected_vars_micro_clean)
set.seed(5162) #Semilla
# Preparar la base de datos para corregir por ppa y dolar.
base_int <- data_macro %>%
left_join(Tipo_Cambio, by = c("Pais", "Ano", "Mes")) %>%
left_join(ppa, by = c("Pais", "Ano")) %>%
mutate(Precio_Int = PrecioU_oferta_usd / (TipoCambio * Factor_PPA)) %>%
filter(is.finite(Precio_Int)) %>%
select(Ano, Mes, Pais,Sub_categoria,GDPpc_miles,Arancel,UrbGrow,Import_PIB, Precio_Int) %>%
mutate(across(c(Pais, Sub_categoria), as.factor))
# Dividir datos y entrenar nuevamente pero con las correciones por ppa y dolar.
idx   <- createDataPartition(base_int$Sub_categoria, p = 0.8, list = FALSE)
train <- base_int[idx, ]
fml   <- Precio_Int ~ .
modelo_rf_int <- train(
fml, data = train, method = "rf",
trControl = trainControl("cv", number = 5), # 5 folds para mayor rapidez
tuneGrid = expand.grid(mtry = 2:4),
ntree = 100 # Es el numero de arboles con los cuales el codigo no se demoraba +1 hora.
)
#Definimos la misma canasta que en p4a y utilizamos el mismo escenario de predicción.
canasta_basica <- c("Arroz", "Fideos", "Aceite", "Panes", "Huevos", "Leches")
canasta_carnes_verduras <- c("Carne roja", "Carne blanca", "Pescados", "Tomates", "Lechuga", "Papas")
canasta_aseo_hogar <- c("Detergentes", "Cloro", "Lavalozas", "Limpia pisos", "Aromatizador")
#definición de las canastas, esto para que luego se unan a los atributos correspondientes.
definicion_canastas <- data.frame(
Sub_categoria = c(canasta_basica, canasta_carnes_verduras,canasta_aseo_hogar),
Canasta = rep(c("Básica", "Carnes y Verduras", "Aseo del Hogar"),
times = c(length(canasta_basica), length(canasta_carnes_verduras),
length(canasta_aseo_hogar))))
escenario_prediccion <- expand.grid(
Sub_categoria = definicion_canastas$Sub_categoria,
Pais          = levels(train$Pais),
Ano           = 2022,
Mes           = 3) %>%
mutate(
GDPpc_miles = case_when(
Pais == "Argentina" ~ 13.935,
Pais == "Chile"     ~ 15.405,
Pais == "Colombia"  ~ 6.680,
Pais == "Perú"      ~ 7.350,
Pais == "Portugal"  ~ 24.620,
Pais == "España"    ~ 30.270,
Pais == "UK"        ~ 46.063
),
Arancel = case_when(
Pais == "Argentina" ~ 11.9,
Pais == "Chile"     ~ 1.0,
Pais == "Colombia"  ~ 3.5,
Pais == "Perú"      ~ 1.1,
Pais == "Portugal"  ~ 1.9,
Pais == "España"    ~ 1.9,
Pais == "UK"        ~ 1.1
),
UrbGrow = case_when(
Pais == "Argentina" ~ 0.3,
Pais == "Chile"     ~ 0.6,
Pais == "Colombia"  ~ 1.4,
Pais == "Perú"      ~ 1.4,
Pais == "Portugal"  ~ 1.5,
Pais == "España"    ~ 1.0,
Pais == "UK"        ~ 1.2
),
Import_PIB = case_when(
Pais == "Argentina" ~ 15.3,
Pais == "Chile"     ~ 39.6,
Pais == "Colombia"  ~ 27.9,
Pais == "Perú"      ~ 28.5,
Pais == "Portugal"  ~ 51.9,
Pais == "España"    ~ 38.9,
Pais == "UK"        ~ 35.3
)
)
#Pronosticar, calcular costos y comparar con lo observado
tabla_comparativa_final <- escenario_prediccion %>%
#Pronosticar precios
mutate(Precio_Predicho_Int = predict(modelo_rf_int, newdata = .)) %>%
left_join(definicion_canastas, by = "Sub_categoria") %>%
#Calcular costo pronosticado de la canasta
group_by(Pais, Canasta) %>%
summarise(Costo_Pronosticado_Int = sum(Precio_Predicho_Int), .groups = "drop") %>%
#Unir con el costo observado
left_join(
base_int %>%
filter(Ano == 2022, Mes %in% c(2, 3)) %>%
group_by(Pais, Sub_categoria) %>%
summarise(Precio_Promedio_Int = mean(Precio_Int, na.rm = TRUE),.groups ="drop") %>%
inner_join(definicion_canastas, by = "Sub_categoria") %>%
group_by(Pais, Canasta) %>%
summarise(Costo_Observado_Int = sum(Precio_Promedio_Int, na.rm = TRUE),.groups = "drop"),by = c("Pais", "Canasta")) %>%
#Añadir la comparación con Chile
group_by(Canasta) %>%
mutate(Ratio_vs_Chile = round(Costo_Pronosticado_Int / Costo_Pronosticado_Int[Pais == "Chile"], 2)) %>%
ungroup() %>%
arrange(Canasta, desc(Costo_Pronosticado_Int))
#Printeamos
kable(tabla_comparativa_final,caption = "Comparación de Costos de Canastas (Pronosticado vs. Observado) en Int$",digits = 2)
